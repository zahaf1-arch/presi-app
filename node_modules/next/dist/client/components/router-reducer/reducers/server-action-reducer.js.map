{"version":3,"sources":["../../../../../src/client/components/router-reducer/reducers/server-action-reducer.ts"],"sourcesContent":["import type {\n  ActionFlightResponse,\n  ActionResult,\n} from '../../../../shared/lib/app-router-types'\nimport { callServer } from '../../../app-call-server'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\nimport {\n  ACTION_HEADER,\n  NEXT_ACTION_NOT_FOUND_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../../app-router-headers'\nimport { UnrecognizedActionError } from '../../unrecognized-action-error'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromFetch as createFromFetchBrowser,\n  createTemporaryReferenceSet,\n  encodeReply,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  ServerActionAction,\n  ServerActionMutable,\n} from '../router-reducer-types'\nimport { assignLocation } from '../../../assign-location'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type { CacheNode } from '../../../../shared/lib/app-router-types'\nimport { handleMutable } from '../handle-mutable'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../../flight-data-helpers'\nimport { getRedirectError } from '../../redirect'\nimport { RedirectType } from '../../redirect-error'\nimport { removeBasePath } from '../../../remove-base-path'\nimport { hasBasePath } from '../../../has-base-path'\nimport {\n  extractInfoFromServerReferenceId,\n  omitUnusedArgs,\n} from '../../../../shared/lib/server-reference-info'\nimport { revalidateEntireCache } from '../../segment-cache/cache'\n\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../../dev/debug-channel') as typeof import('../../../dev/debug-channel')\n  ).createDebugChannel\n}\n\ntype FetchServerActionResult = {\n  redirectLocation: URL | undefined\n  redirectType: RedirectType | undefined\n  actionResult: ActionResult | undefined\n  actionFlightData: NormalizedFlightData[] | string | undefined\n  isPrerender: boolean\n  revalidatedParts: {\n    tag: boolean\n    cookie: boolean\n    paths: string[]\n  }\n}\n\nasync function fetchServerAction(\n  state: ReadonlyReducerState,\n  nextUrl: ReadonlyReducerState['nextUrl'],\n  { actionId, actionArgs }: ServerActionAction\n): Promise<FetchServerActionResult> {\n  const temporaryReferences = createTemporaryReferenceSet()\n  const info = extractInfoFromServerReferenceId(actionId)\n\n  // TODO: Currently, we're only omitting unused args for the experimental \"use\n  // cache\" functions. Once the server reference info byte feature is stable, we\n  // should apply this to server actions as well.\n  const usedArgs =\n    info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs\n\n  const body = await encodeReply(usedArgs, { temporaryReferences })\n\n  const headers: Record<string, string> = {\n    Accept: RSC_CONTENT_TYPE_HEADER,\n    [ACTION_HEADER]: actionId,\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      state.tree\n    ),\n  }\n\n  if (process.env.NEXT_DEPLOYMENT_ID) {\n    headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const res = await fetch(state.canonicalUrl, { method: 'POST', headers, body })\n\n  // Handle server actions that the server didn't recognize.\n  const unrecognizedActionHeader = res.headers.get(NEXT_ACTION_NOT_FOUND_HEADER)\n  if (unrecognizedActionHeader === '1') {\n    throw new UnrecognizedActionError(\n      `Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n    )\n  }\n\n  const redirectHeader = res.headers.get('x-action-redirect')\n  const [location, _redirectType] = redirectHeader?.split(';') || []\n  let redirectType: RedirectType | undefined\n  switch (_redirectType) {\n    case 'push':\n      redirectType = RedirectType.push\n      break\n    case 'replace':\n      redirectType = RedirectType.replace\n      break\n    default:\n      redirectType = undefined\n  }\n\n  const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER)\n  let revalidatedParts: FetchServerActionResult['revalidatedParts']\n  try {\n    const revalidatedHeader = JSON.parse(\n      res.headers.get('x-action-revalidated') || '[[],0,0]'\n    )\n    revalidatedParts = {\n      paths: revalidatedHeader[0] || [],\n      tag: !!revalidatedHeader[1],\n      cookie: revalidatedHeader[2],\n    }\n  } catch (e) {\n    revalidatedParts = NO_REVALIDATED_PARTS\n  }\n\n  const redirectLocation = location\n    ? assignLocation(\n        location,\n        new URL(state.canonicalUrl, window.location.href)\n      )\n    : undefined\n\n  const contentType = res.headers.get('content-type')\n  const isRscResponse = !!(\n    contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n  )\n\n  // Handle invalid server action responses.\n  // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n  // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n  if (!isRscResponse && !redirectLocation) {\n    // The server can respond with a text/plain error message, but we'll fallback to something generic\n    // if there isn't one.\n    const message =\n      res.status >= 400 && contentType === 'text/plain'\n        ? await res.text()\n        : 'An unexpected response was received from the server.'\n\n    throw new Error(message)\n  }\n\n  let actionResult: FetchServerActionResult['actionResult']\n  let actionFlightData: FetchServerActionResult['actionFlightData']\n\n  if (isRscResponse) {\n    const response: ActionFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      {\n        callServer,\n        findSourceMapURL,\n        temporaryReferences,\n        debugChannel: createDebugChannel && createDebugChannel(headers),\n      }\n    )\n\n    // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n    actionResult = redirectLocation ? undefined : response.a\n    actionFlightData = normalizeFlightData(response.f)\n  } else {\n    // An external redirect doesn't contain RSC data.\n    actionResult = undefined\n    actionFlightData = undefined\n  }\n\n  return {\n    actionResult,\n    actionFlightData,\n    redirectLocation,\n    redirectType,\n    revalidatedParts,\n    isPrerender,\n  }\n}\n\nconst NO_REVALIDATED_PARTS = {\n  paths: [],\n  tag: false,\n  cookie: false,\n}\n\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */\nexport function serverActionReducer(\n  state: ReadonlyReducerState,\n  action: ServerActionAction\n): ReducerState {\n  const { resolve, reject } = action\n  const mutable: ServerActionMutable = {}\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n  // If the route has been intercepted, the action should be as well.\n  // Otherwise the server action might be intercepted with the wrong action id\n  // (ie, one that corresponds with the intercepted route)\n  const nextUrl =\n    // We always send the last next-url, not the current when\n    // performing a dynamic request. This is because we update\n    // the next-url after a navigation, but we want the same\n    // interception route to be matched that used the last\n    // next-url.\n    (state.previousNextUrl || state.nextUrl) &&\n    hasInterceptionRouteInCurrentTree(state.tree)\n      ? state.previousNextUrl || state.nextUrl\n      : null\n\n  const navigatedAt = Date.now()\n\n  return fetchServerAction(state, nextUrl, action).then(\n    async ({\n      actionResult,\n      actionFlightData: flightData,\n      redirectLocation,\n      redirectType,\n      revalidatedParts,\n    }) => {\n      let redirectHref: string | undefined\n\n      // honor the redirect type instead of defaulting to push in case of server actions.\n      if (redirectLocation) {\n        if (redirectType === RedirectType.replace) {\n          state.pushRef.pendingPush = false\n          mutable.pendingPush = false\n        } else {\n          state.pushRef.pendingPush = true\n          mutable.pendingPush = true\n        }\n\n        redirectHref = createHrefFromUrl(redirectLocation, false)\n        mutable.canonicalUrl = redirectHref\n      }\n\n      if (!flightData) {\n        resolve(actionResult)\n\n        // If there is a redirect but no flight data we need to do a mpaNavigation.\n        if (redirectLocation) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectLocation.href,\n            state.pushRef.pendingPush\n          )\n        }\n        return state\n      }\n\n      if (typeof flightData === 'string') {\n        // Handle case when navigating to page in `pages` from `app`\n        resolve(actionResult)\n\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      const actionRevalidated =\n        revalidatedParts.paths.length > 0 ||\n        revalidatedParts.tag ||\n        revalidatedParts.cookie\n\n      // Store whether this action triggered any revalidation\n      // The action queue will use this information to potentially\n      // trigger a refresh action if the action was discarded\n      // (ie, due to a navigation, before the action completed)\n      if (actionRevalidated) {\n        action.didRevalidate = true\n      }\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('SERVER ACTION APPLY FAILED')\n          resolve(actionResult)\n\n          return state\n        }\n\n        // Given the path can only have two items the items are only the router state and rsc for the root.\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          redirectHref ? redirectHref : state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          resolve(actionResult)\n\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          resolve(actionResult)\n\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectHref || state.canonicalUrl,\n            state.pushRef.pendingPush\n          )\n        }\n\n        // The server sent back RSC data for the server action, so we need to apply it to the cache.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[0]\n          const cache: CacheNode = createEmptyCacheNode()\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = cacheNodeSeedData[2]\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            cache,\n            // Existing cache is not passed in as server actions have to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n\n          mutable.cache = cache\n          revalidateEntireCache(state.nextUrl, newTree)\n          if (actionRevalidated) {\n            await refreshInactiveParallelSegments({\n              navigatedAt,\n              state,\n              updatedTree: newTree,\n              updatedCache: cache,\n              includeNextUrl: Boolean(nextUrl),\n              canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n            })\n          }\n        }\n\n        mutable.patchedTree = newTree\n        currentTree = newTree\n      }\n\n      if (redirectLocation && redirectHref) {\n        // If the action triggered a redirect, the action promise will be rejected with\n        // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n        // action result to resolve the promise with. This will effectively reset the state of\n        // the component that called the action as the error boundary will remount the tree.\n        // The status code doesn't matter here as the action handler will have already sent\n        // a response with the correct status code.\n        const redirectError = getRedirectError(\n          hasBasePath(redirectHref)\n            ? removeBasePath(redirectHref)\n            : redirectHref,\n          redirectType || RedirectType.push\n        )\n        // We mark the error as handled because we don't want the redirect to be tried later by\n        // the RedirectBoundary, in case the user goes back and `Activity` triggers the redirect\n        // again, as it's run within an effect.\n        // We don't actually need the RedirectBoundary to do a router.push because we already\n        // have all the necessary RSC data to render the new page within a single roundtrip.\n        ;(redirectError as any).handled = true\n        reject(redirectError)\n      } else {\n        resolve(actionResult)\n      }\n\n      return handleMutable(state, mutable)\n    },\n    (e: any) => {\n      // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n      reject(e)\n\n      return state\n    }\n  )\n}\n"],"names":["serverActionReducer","createFromFetch","createFromFetchBrowser","createDebugChannel","process","env","NODE_ENV","__NEXT_REACT_DEBUG_CHANNEL","require","fetchServerAction","state","nextUrl","actionId","actionArgs","temporaryReferences","createTemporaryReferenceSet","info","extractInfoFromServerReferenceId","usedArgs","type","omitUnusedArgs","body","encodeReply","headers","Accept","RSC_CONTENT_TYPE_HEADER","ACTION_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","tree","NEXT_DEPLOYMENT_ID","NEXT_URL","self","__next_r","NEXT_HTML_REQUEST_ID_HEADER","NEXT_REQUEST_ID_HEADER","crypto","getRandomValues","Uint32Array","toString","res","fetch","canonicalUrl","method","unrecognizedActionHeader","get","NEXT_ACTION_NOT_FOUND_HEADER","UnrecognizedActionError","redirectHeader","location","_redirectType","split","redirectType","RedirectType","push","replace","undefined","isPrerender","NEXT_IS_PRERENDER_HEADER","revalidatedParts","revalidatedHeader","JSON","parse","paths","tag","cookie","e","NO_REVALIDATED_PARTS","redirectLocation","assignLocation","URL","window","href","contentType","isRscResponse","startsWith","message","status","text","Error","actionResult","actionFlightData","response","Promise","resolve","callServer","findSourceMapURL","debugChannel","a","normalizeFlightData","f","action","reject","mutable","currentTree","preserveCustomHistoryState","previousNextUrl","hasInterceptionRouteInCurrentTree","navigatedAt","Date","now","then","flightData","redirectHref","pushRef","pendingPush","createHrefFromUrl","handleExternalUrl","actionRevalidated","length","didRevalidate","normalizedFlightData","treePatch","seedData","cacheNodeSeedData","head","isRootRender","console","log","newTree","applyRouterStatePatchToTree","handleSegmentMismatch","isNavigatingToNewRootLayout","rsc","cache","createEmptyCacheNode","prefetchRsc","loading","fillLazyItemsTillLeafWithHead","revalidateEntireCache","refreshInactiveParallelSegments","updatedTree","updatedCache","includeNextUrl","Boolean","patchedTree","redirectError","getRedirectError","hasBasePath","removeBasePath","handled","handleMutable"],"mappings":"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","ignoreList":[0]}