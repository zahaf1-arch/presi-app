{"version":3,"sources":["../../../src/build/static-paths/app.ts"],"sourcesContent":["import type { Params } from '../../server/request/params'\nimport type { AppPageModule } from '../../server/route-modules/app-page/module'\nimport type { AppSegment } from '../segment-config/app/app-segments'\nimport type {\n  FallbackRouteParam,\n  PrerenderedRoute,\n  StaticPathsResult,\n} from './types'\n\nimport path from 'node:path'\nimport { AfterRunner } from '../../server/after/run-with-after'\nimport { createWorkStore } from '../../server/async-storage/work-store'\nimport { FallbackMode } from '../../lib/fallback'\nimport type { IncrementalCache } from '../../server/lib/incremental-cache'\nimport type { LoaderTree } from '../../server/lib/app-dir-module'\nimport {\n  normalizePathname,\n  encodeParam,\n  createFallbackRouteParam,\n} from './utils'\nimport escapePathDelimiters from '../../shared/lib/router/utils/escape-path-delimiters'\nimport { createIncrementalCache } from '../../export/helpers/create-incremental-cache'\nimport type { NextConfigComplete } from '../../server/config-shared'\nimport type { WorkStore } from '../../server/app-render/work-async-storage.external'\nimport type { DynamicParamTypes } from '../../shared/lib/app-router-types'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  getParamProperties,\n  getSegmentParam,\n} from '../../shared/lib/router/utils/get-segment-param'\nimport { parseLoaderTree } from '../../shared/lib/router/utils/parse-loader-tree'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../shared/lib/router/utils/interception-routes'\nimport { throwEmptyGenerateStaticParamsError } from '../../shared/lib/errors/empty-generate-static-params-error'\nimport type { AppRouteModule } from '../../server/route-modules/app-route/module.compiled'\n\n/**\n * Filters out duplicate parameters from a list of parameters.\n * This function uses a Map to efficiently store and retrieve unique parameter combinations.\n *\n * @param childrenRouteParams - The keys of the parameters. These should be sorted to ensure consistent key generation.\n * @param routeParams - The list of parameter objects to filter.\n * @returns A new array containing only the unique parameter combinations.\n */\nexport function filterUniqueParams(\n  childrenRouteParams: readonly { paramName: string }[],\n  routeParams: readonly Params[]\n): Params[] {\n  // A Map is used to store unique parameter combinations. The key of the Map\n  // is a string representation of the parameter combination, and the value\n  // is the actual `Params` object.\n  const unique = new Map<string, Params>()\n\n  // Iterate over each parameter object in the input array.\n  for (const params of routeParams) {\n    let key = '' // Initialize an empty string to build the unique key for the current `params` object.\n\n    // Iterate through the `routeParamKeys` (which are assumed to be sorted).\n    // This consistent order is crucial for generating a stable and unique key\n    // for each parameter combination.\n    for (const { paramName: paramKey } of childrenRouteParams) {\n      const value = params[paramKey]\n\n      // Construct a part of the key using the parameter key and its value.\n      // A type prefix (`A:` for Array, `S:` for String, `U:` for undefined) is added to the value\n      // to prevent collisions. For example, `['a', 'b']` and `'a,b'` would\n      // otherwise generate the same string representation, leading to incorrect\n      // deduplication. This ensures that different types with the same string\n      // representation are treated as distinct.\n      let valuePart: string\n      if (Array.isArray(value)) {\n        valuePart = `A:${value.join(',')}`\n      } else if (value === undefined) {\n        valuePart = `U:undefined`\n      } else {\n        valuePart = `S:${value}`\n      }\n      key += `${paramKey}:${valuePart}|`\n    }\n\n    // If the generated key is not already in the `unique` Map, it means this\n    // parameter combination is unique so far. Add it to the Map.\n    if (!unique.has(key)) {\n      unique.set(key, params)\n    }\n  }\n\n  // Convert the Map's values (the unique `Params` objects) back into an array\n  // and return it.\n  return Array.from(unique.values())\n}\n\n/**\n * Generates all unique sub-combinations of Route Parameters from a list of Static Parameters.\n * This function creates all possible prefixes of the Route Parameters, which is\n * useful for generating Static Shells that can serve as Fallback Shells for more specific Route Shells.\n *\n * When Root Parameters are provided, the function ensures that Static Shells only\n * include complete sets of Root Parameters. This prevents generating invalid Static Shells\n * that are missing required Root Parameters.\n *\n * Example with Root Parameters ('lang', 'region') and Route Parameters ('lang', 'region', 'slug'):\n *\n * Given the following Static Parameters:\n * ```\n * [\n *   { lang: 'en', region: 'US', slug: ['home'] },\n *   { lang: 'en', region: 'US', slug: ['about'] },\n *   { lang: 'fr', region: 'CA', slug: ['about'] },\n * ]\n * ```\n *\n * The result will be:\n * ```\n * [\n *   { lang: 'en', region: 'US' },  // Complete Root Parameters\n *   { lang: 'en', region: 'US', slug: ['home'] },\n *   { lang: 'en', region: 'US', slug: ['about'] },\n *   { lang: 'fr', region: 'CA' },  // Complete Root Parameters\n *   { lang: 'fr', region: 'CA', slug: ['about'] },\n * ]\n * ```\n *\n * Note that partial combinations like `{ lang: 'en' }` are NOT generated because\n * they don't include the complete set of Root Parameters.\n *\n * For routes without Root Parameters (e.g., `/[slug]`), all sub-combinations are generated\n * as before.\n *\n * @param childrenRouteParams - The children route params. These should be sorted\n *   to ensure consistent key generation for the internal Map.\n * @param routeParams - The list of Static Parameters to filter.\n * @param rootParamKeys - The keys of the Root Parameters. When provided, ensures Static Shells\n *   include all Root Parameters.\n * @returns A new array containing all unique sub-combinations of Route Parameters.\n */\nexport function generateAllParamCombinations(\n  childrenRouteParams: ReadonlyArray<{\n    readonly paramName: string\n  }>,\n  routeParams: readonly Params[],\n  rootParamKeys: readonly string[]\n): Params[] {\n  // A Map is used to store unique combinations of Route Parameters.\n  // The key of the Map is a string representation of the Route Parameter\n  // combination, and the value is the `Params` object containing only\n  // the Route Parameters.\n  const combinations = new Map<string, Params>()\n\n  // Determine the minimum index where all Root Parameters are included.\n  // This optimization ensures we only generate combinations that include\n  // a complete set of Root Parameters, preventing invalid Static Shells.\n  //\n  // For example, if rootParamKeys = ['lang', 'region'] and routeParamKeys = ['lang', 'region', 'slug']:\n  // - 'lang' is at index 0, 'region' is at index 1\n  // - minIndexForCompleteRootParams = max(0, 1) = 1\n  // - We'll only generate combinations starting from index 1 (which includes both lang and region)\n  let minIndexForCompleteRootParams = -1\n  if (rootParamKeys.length > 0) {\n    // Find the index of the last Root Parameter in routeParamKeys.\n    // This tells us the minimum combination length needed to include all Root Parameters.\n    for (const rootParamKey of rootParamKeys) {\n      const index = childrenRouteParams.findIndex(\n        (param) => param.paramName === rootParamKey\n      )\n      if (index === -1) {\n        // Root Parameter not found in Route Parameters - this shouldn't happen in normal cases\n        // but we handle it gracefully by treating it as if there are no Root Parameters.\n        // This allows the function to fall back to generating all sub-combinations.\n        minIndexForCompleteRootParams = -1\n        break\n      }\n      // Track the highest index among all Root Parameters.\n      // This ensures all Root Parameters are included in any generated combination.\n      minIndexForCompleteRootParams = Math.max(\n        minIndexForCompleteRootParams,\n        index\n      )\n    }\n  }\n\n  // Iterate over each Static Parameter object in the input array.\n  // Each params object represents one potential route combination (e.g., { lang: 'en', region: 'US', slug: 'home' })\n  for (const params of routeParams) {\n    // Generate all possible prefix combinations for this Static Parameter set.\n    // For routeParamKeys = ['lang', 'region', 'slug'], we'll generate combinations at:\n    // - i=0: { lang: 'en' }\n    // - i=1: { lang: 'en', region: 'US' }\n    // - i=2: { lang: 'en', region: 'US', slug: 'home' }\n    //\n    // The iteration order is crucial for generating stable and unique keys\n    // for each Route Parameter combination.\n    for (let i = 0; i < childrenRouteParams.length; i++) {\n      // Skip generating combinations that don't include all Root Parameters.\n      // This prevents creating invalid Static Shells that are missing required Root Parameters.\n      //\n      // For example, if Root Parameters are ['lang', 'region'] and minIndexForCompleteRootParams = 1:\n      // - Skip i=0 (would only include 'lang', missing 'region')\n      // - Process i=1 and higher (includes both 'lang' and 'region')\n      if (\n        minIndexForCompleteRootParams >= 0 &&\n        i < minIndexForCompleteRootParams\n      ) {\n        continue\n      }\n\n      // Initialize data structures for building this specific combination\n      const combination: Params = {}\n      const keyParts: string[] = []\n      let hasAllRootParams = true\n\n      // Build the sub-combination with parameters from index 0 to i (inclusive).\n      // This creates a prefix of the full parameter set, building up combinations incrementally.\n      //\n      // For example, if routeParamKeys = ['lang', 'region', 'slug'] and i = 1:\n      // - j=0: Add 'lang' parameter\n      // - j=1: Add 'region' parameter\n      // Result: { lang: 'en', region: 'US' }\n      for (let j = 0; j <= i; j++) {\n        const { paramName: routeKey } = childrenRouteParams[j]\n\n        // Check if the parameter exists in the original params object and has a defined value.\n        // This handles cases where generateStaticParams doesn't provide all possible parameters,\n        // or where some parameters are optional/undefined.\n        if (\n          !params.hasOwnProperty(routeKey) ||\n          params[routeKey] === undefined\n        ) {\n          // If this missing parameter is a Root Parameter, mark the combination as invalid.\n          // Root Parameters are required for Static Shells, so we can't generate partial combinations without them.\n          if (rootParamKeys.includes(routeKey)) {\n            hasAllRootParams = false\n          }\n          // Stop building this combination since we've hit a missing parameter.\n          // This ensures we only generate valid prefix combinations with consecutive parameters.\n          break\n        }\n\n        const value = params[routeKey]\n        combination[routeKey] = value\n\n        // Construct a unique key part for this parameter to enable deduplication.\n        // We use type prefixes to prevent collisions between different value types\n        // that might have the same string representation.\n        //\n        // Examples:\n        // - Array ['foo', 'bar'] becomes \"A:foo,bar\"\n        // - String \"foo,bar\" becomes \"S:foo,bar\"\n        // - This prevents collisions between ['foo', 'bar'] and \"foo,bar\"\n        let valuePart: string\n        if (Array.isArray(value)) {\n          valuePart = `A:${value.join(',')}`\n        } else {\n          valuePart = `S:${value}`\n        }\n        keyParts.push(`${routeKey}:${valuePart}`)\n      }\n\n      // Build the final unique key by joining all parameter parts.\n      // This key is used for deduplication in the combinations Map.\n      // Format: \"lang:S:en|region:S:US|slug:A:home,about\"\n      const currentKey = keyParts.join('|')\n\n      // Only add the combination if it meets our criteria:\n      // 1. hasAllRootParams: Contains all required Root Parameters\n      // 2. !combinations.has(currentKey): Is not a duplicate of an existing combination\n      //\n      // This ensures we only generate valid, unique parameter combinations for Static Shells.\n      if (hasAllRootParams && !combinations.has(currentKey)) {\n        combinations.set(currentKey, combination)\n      }\n    }\n  }\n\n  // Convert the Map's values back into an array and return the final result.\n  // The Map ensures all combinations are unique, and we return only the\n  // parameter objects themselves, discarding the internal deduplication keys.\n  return Array.from(combinations.values())\n}\n\n/**\n * Calculates the fallback mode based on the given parameters.\n *\n * @param dynamicParams - Whether dynamic params are enabled.\n * @param fallbackRootParams - The root params that are part of the fallback.\n * @param baseFallbackMode - The base fallback mode to use.\n * @returns The calculated fallback mode.\n */\nexport function calculateFallbackMode(\n  dynamicParams: boolean,\n  fallbackRootParams: readonly string[],\n  baseFallbackMode: FallbackMode | undefined\n): FallbackMode {\n  return dynamicParams\n    ? // If the fallback params includes any root params, then we need to\n      // perform a blocking static render.\n      fallbackRootParams.length > 0\n      ? FallbackMode.BLOCKING_STATIC_RENDER\n      : (baseFallbackMode ?? FallbackMode.NOT_FOUND)\n    : FallbackMode.NOT_FOUND\n}\n\n/**\n * Validates the parameters to ensure they're accessible and have the correct\n * types.\n *\n * @param page - The page to validate.\n * @param regex - The route regex.\n * @param isRoutePPREnabled - Whether the route has partial prerendering enabled.\n * @param childrenRouteParamSegments - The keys of the parameters.\n * @param rootParamKeys - The keys of the root params.\n * @param routeParams - The list of parameters to validate.\n * @returns The list of validated parameters.\n */\nfunction validateParams(\n  page: string,\n  isRoutePPREnabled: boolean,\n  childrenRouteParamSegments: ReadonlyArray<{\n    readonly paramName: string\n    readonly paramType: DynamicParamTypes\n  }>,\n  rootParamKeys: readonly string[],\n  routeParams: readonly Params[]\n): Params[] {\n  const valid: Params[] = []\n\n  // Validate that if there are any root params, that the user has provided at\n  // least one value for them only if we're using partial prerendering.\n  if (isRoutePPREnabled && rootParamKeys.length > 0) {\n    if (\n      routeParams.length === 0 ||\n      rootParamKeys.some((key) =>\n        routeParams.some((params) => !(key in params))\n      )\n    ) {\n      if (rootParamKeys.length === 1) {\n        throw new Error(\n          `A required root parameter (${rootParamKeys[0]}) was not provided in generateStaticParams for ${page}, please provide at least one value.`\n        )\n      }\n\n      throw new Error(\n        `Required root params (${rootParamKeys.join(', ')}) were not provided in generateStaticParams for ${page}, please provide at least one value for each.`\n      )\n    }\n  }\n\n  for (const params of routeParams) {\n    const item: Params = {}\n\n    for (const { paramName: key, paramType } of childrenRouteParamSegments) {\n      const { repeat, optional } = getParamProperties(paramType)\n\n      let paramValue = params[key]\n\n      if (\n        optional &&\n        params.hasOwnProperty(key) &&\n        (paramValue === null ||\n          paramValue === undefined ||\n          (paramValue as any) === false)\n      ) {\n        paramValue = []\n      }\n\n      // A parameter is missing, so the rest of the params are not accessible.\n      // We only support this when the route has partial prerendering enabled.\n      // This will make it so that the remaining params are marked as missing so\n      // we can generate a fallback route for them.\n      if (!paramValue && isRoutePPREnabled) {\n        break\n      }\n\n      // Perform validation for the parameter based on whether it's a repeat\n      // parameter or not.\n      if (repeat) {\n        if (!Array.isArray(paramValue)) {\n          throw new Error(\n            `A required parameter (${key}) was not provided as an array received ${typeof paramValue} in generateStaticParams for ${page}`\n          )\n        }\n      } else {\n        if (typeof paramValue !== 'string') {\n          throw new Error(\n            `A required parameter (${key}) was not provided as a string received ${typeof paramValue} in generateStaticParams for ${page}`\n          )\n        }\n      }\n\n      item[key] = paramValue\n    }\n\n    valid.push(item)\n  }\n\n  return valid\n}\n\ninterface TrieNode {\n  /**\n   * The children of the node. Each key is a unique string representation of a parameter value,\n   * and the value is the next TrieNode in the path.\n   */\n  children: Map<string, TrieNode>\n\n  /**\n   * The routes that are associated with this specific parameter combination (node).\n   * These are the routes whose concrete parameters lead to this node in the Trie.\n   */\n  routes: PrerenderedRoute[]\n}\n\n/**\n * Assigns the throwOnEmptyStaticShell property to each of the prerendered routes.\n * This function uses a Trie data structure to efficiently determine whether each route\n * should throw an error when its static shell is empty.\n *\n * A route should not throw on empty static shell if it has child routes in the Trie. For example,\n * if we have two routes, `/blog/first-post` and `/blog/[slug]`, the route for\n * `/blog/[slug]` should not throw because `/blog/first-post` is a more specific concrete route.\n *\n * @param prerenderedRoutes - The prerendered routes.\n * @param childrenRouteParams - The keys of the route parameters.\n */\nexport function assignErrorIfEmpty(\n  prerenderedRoutes: readonly PrerenderedRoute[],\n  childrenRouteParams: ReadonlyArray<{\n    readonly paramName: string\n  }>\n): void {\n  // If there are no routes to process, exit early.\n  if (prerenderedRoutes.length === 0) {\n    return\n  }\n\n  // Initialize the root of the Trie. This node represents the starting point\n  // before any parameters have been considered.\n  const root: TrieNode = { children: new Map(), routes: [] }\n\n  // Phase 1: Build the Trie.\n  // Iterate over each prerendered route and insert it into the Trie.\n  // Each route's concrete parameter values form a path in the Trie.\n  for (const route of prerenderedRoutes) {\n    let currentNode = root // Start building the path from the root for each route.\n\n    // Iterate through the sorted parameter keys. The order of keys is crucial\n    // for ensuring that routes with the same concrete parameters follow the\n    // same path in the Trie, regardless of the original order of properties\n    // in the `params` object.\n    for (const { paramName: key } of childrenRouteParams) {\n      // Check if the current route actually has a concrete value for this parameter.\n      // If a dynamic segment is not filled (i.e., it's a fallback), it won't have\n      // this property, and we stop building the path for this route at this point.\n      if (route.params.hasOwnProperty(key)) {\n        const value = route.params[key]\n\n        // Generate a unique key for the parameter's value. This is critical\n        // to prevent collisions between different data types that might have\n        // the same string representation (e.g., `['a', 'b']` vs `'a,b'`).\n        // A type prefix (`A:` for Array, `S:` for String, `U:` for undefined)\n        // is added to the value to prevent collisions. This ensures that\n        // different types with the same string representation are treated as\n        // distinct.\n        let valueKey: string\n        if (Array.isArray(value)) {\n          valueKey = `A:${value.join(',')}`\n        } else if (value === undefined) {\n          valueKey = `U:undefined`\n        } else {\n          valueKey = `S:${value}`\n        }\n\n        // Look for a child node corresponding to this `valueKey` from the `currentNode`.\n        let childNode = currentNode.children.get(valueKey)\n        if (!childNode) {\n          // If the child node doesn't exist, create a new one and add it to\n          // the current node's children.\n          childNode = { children: new Map(), routes: [] }\n          currentNode.children.set(valueKey, childNode)\n        }\n        // Move deeper into the Trie to the `childNode` for the next parameter.\n        currentNode = childNode\n      }\n    }\n    // After processing all concrete parameters for the route, add the full\n    // `PrerenderedRoute` object to the `routes` array of the `currentNode`.\n    // This node represents the unique concrete parameter combination for this route.\n    currentNode.routes.push(route)\n  }\n\n  // Phase 2: Traverse the Trie to assign the `throwOnEmptyStaticShell` property.\n  // This is done using an iterative Depth-First Search (DFS) approach with an\n  // explicit stack to avoid JavaScript's recursion depth limits (stack overflow)\n  // for very deep routing structures.\n  const stack: TrieNode[] = [root] // Initialize the stack with the root node.\n\n  while (stack.length > 0) {\n    const node = stack.pop()! // Pop the next node to process from the stack.\n\n    // `hasChildren` indicates if this node has any more specific concrete\n    // parameter combinations branching off from it. If true, it means this\n    // node represents a prefix for other, more specific routes.\n    const hasChildren = node.children.size > 0\n\n    // If the current node has routes associated with it (meaning, routes whose\n    // concrete parameters lead to this node's path in the Trie).\n    if (node.routes.length > 0) {\n      // Determine the minimum number of fallback parameters among all routes\n      // that are associated with this current Trie node. This is used to\n      // identify if a route should not throw on empty static shell relative to another route *at the same level*\n      // of concrete parameters, but with fewer fallback parameters.\n      let minFallbacks = Infinity\n      for (const r of node.routes) {\n        // `fallbackRouteParams?.length ?? 0` handles cases where `fallbackRouteParams`\n        // might be `undefined` or `null`, treating them as 0 length.\n        minFallbacks = Math.min(\n          minFallbacks,\n          r.fallbackRouteParams ? r.fallbackRouteParams.length : 0\n        )\n      }\n\n      // Now, for each `PrerenderedRoute` associated with this node:\n      for (const route of node.routes) {\n        // A route is ok not to throw on an empty static shell (and thus\n        // `throwOnEmptyStaticShell` should be `false`) if either of the\n        // following conditions is met:\n        // 1. `hasChildren` is true: This node has further concrete parameter children.\n        //    This means the current route is a parent to more specific routes (e.g.,\n        //    `/blog/[slug]` should not throw when concrete routes like `/blog/first-post` exist).\n        // OR\n        // 2. `route.fallbackRouteParams.length > minFallbacks`: This route has\n        //    more fallback parameters than another route at the same Trie node.\n        //    This implies the current route is a more general version that should not throw\n        //    compared to a more specific route that has fewer fallback parameters\n        //    (e.g., `/1234/[...slug]` should not throw relative to `/[id]/[...slug]`).\n        if (\n          hasChildren ||\n          (route.fallbackRouteParams &&\n            route.fallbackRouteParams.length > minFallbacks)\n        ) {\n          route.throwOnEmptyStaticShell = false // Should not throw on empty static shell.\n        } else {\n          route.throwOnEmptyStaticShell = true // Should throw on empty static shell.\n        }\n      }\n    }\n\n    // Add all children of the current node to the stack. This ensures that\n    // the traversal continues to explore deeper paths in the Trie.\n    for (const child of node.children.values()) {\n      stack.push(child)\n    }\n  }\n}\n\n/**\n * Resolves parallel route parameters from the loader tree. This function uses\n * tree-based traversal to correctly handle the hierarchical structure of parallel\n * routes and accurately determine parameter values based on their depth in the tree.\n *\n * Unlike interpolateParallelRouteParams (which has a complete URL at runtime),\n * this build-time function determines which parallel route params are unknown.\n * The pathname may contain placeholders like [slug], making it incomplete.\n *\n * @param loaderTree - The loader tree structure containing route hierarchy\n * @param params - The current route parameters object (will be mutated)\n * @param pathname - The current pathname being processed (may contain placeholders)\n * @param fallbackRouteParams - Array of fallback route parameters (will be mutated)\n */\nexport function resolveParallelRouteParams(\n  loaderTree: LoaderTree,\n  params: Params,\n  pathname: string,\n  fallbackRouteParams: FallbackRouteParam[]\n): void {\n  // Stack-based traversal with depth and parallel route key tracking\n  const stack: Array<{\n    tree: LoaderTree\n    depth: number\n    parallelKey: string\n  }> = [{ tree: loaderTree, depth: 0, parallelKey: 'children' }]\n\n  // Parse pathname into segments for depth-based resolution\n  const pathSegments = pathname.split('/').filter(Boolean)\n\n  while (stack.length > 0) {\n    const { tree, depth, parallelKey } = stack.pop()!\n    const { segment, parallelRoutes } = parseLoaderTree(tree)\n\n    // Only process segments that are in parallel routes (not the main 'children' route)\n    if (parallelKey !== 'children') {\n      const segmentParam = getSegmentParam(segment)\n\n      if (segmentParam && !params.hasOwnProperty(segmentParam.param)) {\n        const { param: paramName, type: paramType } = segmentParam\n\n        switch (paramType) {\n          case 'catchall':\n          case 'optional-catchall':\n          case 'catchall-intercepted-(..)(..)':\n          case 'catchall-intercepted-(.)':\n          case 'catchall-intercepted-(..)':\n          case 'catchall-intercepted-(...)':\n            // If there are any non-parallel fallback route segments, we can't use the\n            // pathname to derive the value because it's not complete. We can make\n            // this assumption because routes are resolved left to right.\n            if (\n              fallbackRouteParams.some((param) => !param.isParallelRouteParam)\n            ) {\n              fallbackRouteParams.push(\n                createFallbackRouteParam(paramName, paramType, true)\n              )\n              break\n            }\n\n            // For catchall routes in parallel segments, derive from pathname\n            // using depth to determine which segments to use\n            const remainingSegments = pathSegments.slice(depth)\n\n            // Process segments to handle any embedded dynamic params\n            // Track if we encounter any unknown param placeholders\n            let hasUnknownParam = false\n            const processedSegments = remainingSegments\n              .flatMap((pathSegment) => {\n                const param = getSegmentParam(pathSegment)\n                if (param) {\n                  // If the segment is a param placeholder, check if we have its value\n                  if (!params.hasOwnProperty(param.param)) {\n                    // Unknown param placeholder in pathname - can't derive full value\n                    hasUnknownParam = true\n                    return undefined\n                  }\n                  // If the segment matches a param, return the param value\n                  // We don't encode values here as that's handled during retrieval.\n                  return params[param.param]\n                }\n                // Otherwise it's a static segment\n                return pathSegment\n              })\n              .filter((s) => s !== undefined)\n\n            // If we encountered any unknown param placeholders, we can't derive\n            // the full catch-all value from the pathname, so mark as fallback.\n            if (hasUnknownParam) {\n              fallbackRouteParams.push(\n                createFallbackRouteParam(paramName, paramType, true)\n              )\n              break\n            }\n\n            if (processedSegments.length > 0) {\n              params[paramName] = processedSegments\n            } else if (paramType === 'optional-catchall') {\n              params[paramName] = []\n            } else {\n              // We shouldn't be able to match a catchall segment without any path\n              // segments if it's not an optional catchall\n              throw new InvariantError(\n                `Unexpected empty path segments match for a pathname \"${pathname}\" with param \"${paramName}\" of type \"${paramType}\"`\n              )\n            }\n            break\n\n          case 'dynamic':\n          case 'dynamic-intercepted-(..)(..)':\n          case 'dynamic-intercepted-(.)':\n          case 'dynamic-intercepted-(..)':\n          case 'dynamic-intercepted-(...)':\n            // For regular dynamic parameters, take the segment at this depth\n            if (depth < pathSegments.length) {\n              const pathSegment = pathSegments[depth]\n              const param = getSegmentParam(pathSegment)\n\n              // Check if the segment at this depth is a placeholder for an unknown param\n              if (param && !params.hasOwnProperty(param.param)) {\n                // The segment is a placeholder like [category] and we don't have the value\n                fallbackRouteParams.push(\n                  createFallbackRouteParam(paramName, paramType, true)\n                )\n                break\n              }\n\n              // If the segment matches a param, use the param value from params object\n              // Otherwise it's a static segment, just use it directly\n              // We don't encode values here as that's handled during retrieval\n              params[paramName] = param ? params[param.param] : pathSegment\n            } else {\n              // No segment at this depth, mark as fallback.\n              fallbackRouteParams.push(\n                createFallbackRouteParam(paramName, paramType, true)\n              )\n            }\n            break\n\n          default:\n            paramType satisfies never\n        }\n      }\n    }\n\n    // Calculate next depth - increment if this is not a route group and not empty\n    let nextDepth = depth\n    // Route groups are like (marketing) or (dashboard), NOT interception routes like (.)photo\n    // Interception routes start with markers like (.), (..), (...), (..)(..)) and should increment depth\n    const isInterceptionRoute = INTERCEPTION_ROUTE_MARKERS.some((marker) =>\n      segment.startsWith(marker)\n    )\n    const isRouteGroup =\n      !isInterceptionRoute && segment.startsWith('(') && segment.endsWith(')')\n    if (!isRouteGroup && segment !== '') {\n      nextDepth++\n    }\n\n    // Add all parallel routes to the stack for processing.\n    for (const [key, route] of Object.entries(parallelRoutes)) {\n      stack.push({ tree: route, depth: nextDepth, parallelKey: key })\n    }\n  }\n}\n\n/**\n * Processes app directory segments to build route parameters from generateStaticParams functions.\n * This function walks through the segments array and calls generateStaticParams for each segment that has it,\n * combining parent parameters with child parameters to build the complete parameter combinations.\n * Uses iterative processing instead of recursion for better performance.\n *\n * @param segments - Array of app directory segments to process\n * @param store - Work store for tracking fetch cache configuration\n * @returns Promise that resolves to an array of all parameter combinations\n */\nexport async function generateRouteStaticParams(\n  segments: ReadonlyArray<\n    Readonly<Pick<AppSegment, 'config' | 'generateStaticParams'>>\n  >,\n  store: Pick<WorkStore, 'fetchCache'>,\n  isRoutePPREnabled: boolean\n): Promise<Params[]> {\n  // Early return if no segments to process\n  if (segments.length === 0) return []\n\n  // Use iterative processing with a work queue to avoid recursion overhead\n  interface WorkItem {\n    segmentIndex: number\n    params: Params[]\n  }\n\n  const queue: WorkItem[] = [{ segmentIndex: 0, params: [] }]\n  let currentParams: Params[] = []\n\n  while (queue.length > 0) {\n    const { segmentIndex, params } = queue.shift()!\n\n    // If we've processed all segments, this is our final result\n    if (segmentIndex >= segments.length) {\n      currentParams = params\n      break\n    }\n\n    const current = segments[segmentIndex]\n\n    // Skip segments without generateStaticParams and continue to next\n    if (typeof current.generateStaticParams !== 'function') {\n      queue.push({ segmentIndex: segmentIndex + 1, params })\n      continue\n    }\n\n    // Configure fetchCache if specified\n    if (current.config?.fetchCache !== undefined) {\n      store.fetchCache = current.config.fetchCache\n    }\n\n    const nextParams: Params[] = []\n\n    // If there are parent params, we need to process them.\n    if (params.length > 0) {\n      // Process each parent parameter combination\n      for (const parentParams of params) {\n        const result = await current.generateStaticParams({\n          params: parentParams,\n        })\n\n        if (result.length > 0) {\n          // Merge parent params with each result item\n          for (const item of result) {\n            nextParams.push({ ...parentParams, ...item })\n          }\n        } else if (isRoutePPREnabled) {\n          throwEmptyGenerateStaticParamsError()\n        } else {\n          // No results, just pass through parent params\n          nextParams.push(parentParams)\n        }\n      }\n    } else {\n      // No parent params, call generateStaticParams with empty object\n      const result = await current.generateStaticParams({ params: {} })\n      if (result.length === 0 && isRoutePPREnabled) {\n        throwEmptyGenerateStaticParamsError()\n      }\n\n      nextParams.push(...result)\n    }\n\n    // Add next segment to work queue\n    queue.push({ segmentIndex: segmentIndex + 1, params: nextParams })\n  }\n\n  return currentParams\n}\n\n/**\n * Builds the static paths for an app using `generateStaticParams`.\n *\n * @param params - The parameters for the build.\n * @returns The static paths.\n */\nexport async function buildAppStaticPaths({\n  dir,\n  page,\n  distDir,\n  cacheComponents,\n  authInterrupts,\n  segments,\n  isrFlushToDisk,\n  cacheHandler,\n  cacheLifeProfiles,\n  requestHeaders,\n  cacheHandlers,\n  cacheMaxMemorySize,\n  fetchCacheKeyPrefix,\n  nextConfigOutput,\n  ComponentMod,\n  isRoutePPREnabled = false,\n  buildId,\n  rootParamKeys,\n}: {\n  dir: string\n  page: string\n  cacheComponents: boolean\n  authInterrupts: boolean\n  segments: readonly Readonly<AppSegment>[]\n  distDir: string\n  isrFlushToDisk?: boolean\n  fetchCacheKeyPrefix?: string\n  cacheHandler?: string\n  cacheHandlers?: NextConfigComplete['cacheHandlers']\n  cacheLifeProfiles?: {\n    [profile: string]: import('../../server/use-cache/cache-life').CacheLife\n  }\n  cacheMaxMemorySize: number\n  requestHeaders: IncrementalCache['requestHeaders']\n  nextConfigOutput: 'standalone' | 'export' | undefined\n  ComponentMod: AppPageModule | AppRouteModule\n  isRoutePPREnabled: boolean\n  buildId: string\n  rootParamKeys: readonly string[]\n}): Promise<StaticPathsResult> {\n  if (\n    segments.some((generate) => generate.config?.dynamicParams === true) &&\n    nextConfigOutput === 'export'\n  ) {\n    throw new Error(\n      '\"dynamicParams: true\" cannot be used with \"output: export\". See more info here: https://nextjs.org/docs/app/building-your-application/deploying/static-exports'\n    )\n  }\n\n  ComponentMod.patchFetch()\n\n  const incrementalCache = await createIncrementalCache({\n    dir,\n    distDir,\n    cacheHandler,\n    cacheHandlers,\n    requestHeaders,\n    fetchCacheKeyPrefix,\n    flushToDisk: isrFlushToDisk,\n    cacheMaxMemorySize,\n  })\n\n  const childrenRouteParamSegments: Array<{\n    readonly name: string\n    readonly paramName: string\n    readonly paramType: DynamicParamTypes\n  }> = []\n\n  // These are all the parallel fallback route params that will be included when\n  // we're emitting the route for the base route.\n  const parallelFallbackRouteParams: FallbackRouteParam[] = []\n\n  // First pass: collect all non-parallel route param names.\n  // This allows us to filter out parallel route params that duplicate non-parallel ones.\n  const nonParallelParamNames = new Set<string>()\n  for (const segment of segments) {\n    if (!segment.paramName || !segment.paramType) continue\n    if (!segment.isParallelRouteSegment) {\n      nonParallelParamNames.add(segment.paramName)\n    }\n  }\n\n  // Second pass: collect segments, ensuring non-parallel route params take precedence.\n  for (const segment of segments) {\n    // If this segment doesn't have a param name then it's not param that we\n    // need to resolve.\n    if (!segment.paramName || !segment.paramType) continue\n\n    if (segment.isParallelRouteSegment) {\n      // Skip parallel route params that are already defined as non-parallel route params.\n      // Non-parallel route params take precedence because they appear in the URL pathname.\n      if (nonParallelParamNames.has(segment.paramName)) {\n        continue\n      }\n\n      // Collect parallel fallback route params for the base route.\n      // The actual parallel route param resolution is now handled by\n      // resolveParallelRouteParams using the loader tree.\n      parallelFallbackRouteParams.push(\n        createFallbackRouteParam(segment.paramName, segment.paramType, true)\n      )\n    } else {\n      // Collect all the route param keys that are not parallel route params.\n      // These are the ones that will be included in the request pathname.\n      childrenRouteParamSegments.push({\n        name: segment.name,\n        paramName: segment.paramName,\n        paramType: segment.paramType,\n      })\n    }\n  }\n\n  const afterRunner = new AfterRunner()\n\n  const store = createWorkStore({\n    page,\n    renderOpts: {\n      incrementalCache,\n      cacheLifeProfiles,\n      supportsDynamicResponse: true,\n      cacheComponents,\n      experimental: {\n        authInterrupts,\n      },\n      waitUntil: afterRunner.context.waitUntil,\n      onClose: afterRunner.context.onClose,\n      onAfterTaskError: afterRunner.context.onTaskError,\n    },\n    buildId,\n    previouslyRevalidatedTags: [],\n  })\n\n  const routeParams = await ComponentMod.workAsyncStorage.run(\n    store,\n    generateRouteStaticParams,\n    segments,\n    store,\n    isRoutePPREnabled\n  )\n\n  await afterRunner.executeAfter()\n\n  let lastDynamicSegmentHadGenerateStaticParams = false\n  for (const segment of segments) {\n    // Check to see if there are any missing params for segments that have\n    // dynamicParams set to false.\n    if (\n      segment.paramName &&\n      segment.isDynamicSegment &&\n      segment.config?.dynamicParams === false\n    ) {\n      for (const params of routeParams) {\n        if (segment.paramName in params) continue\n\n        const relative = segment.filePath\n          ? path.relative(dir, segment.filePath)\n          : undefined\n\n        throw new Error(\n          `Segment \"${relative}\" exports \"dynamicParams: false\" but the param \"${segment.paramName}\" is missing from the generated route params.`\n        )\n      }\n    }\n\n    if (\n      segment.isDynamicSegment &&\n      typeof segment.generateStaticParams !== 'function'\n    ) {\n      lastDynamicSegmentHadGenerateStaticParams = false\n    } else if (typeof segment.generateStaticParams === 'function') {\n      lastDynamicSegmentHadGenerateStaticParams = true\n    }\n  }\n\n  // Determine if all the segments have had their parameters provided.\n  const hadAllParamsGenerated =\n    childrenRouteParamSegments.length === 0 ||\n    (routeParams.length > 0 &&\n      routeParams.every((params) => {\n        for (const { paramName } of childrenRouteParamSegments) {\n          if (paramName in params) continue\n          return false\n        }\n        return true\n      }))\n\n  // TODO: dynamic params should be allowed to be granular per segment but\n  // we need additional information stored/leveraged in the prerender\n  // manifest to allow this behavior.\n  const dynamicParams = segments.every(\n    (segment) => segment.config?.dynamicParams !== false\n  )\n\n  const supportsRoutePreGeneration =\n    hadAllParamsGenerated || process.env.NODE_ENV === 'production'\n\n  const fallbackMode = dynamicParams\n    ? supportsRoutePreGeneration\n      ? isRoutePPREnabled\n        ? FallbackMode.PRERENDER\n        : FallbackMode.BLOCKING_STATIC_RENDER\n      : undefined\n    : FallbackMode.NOT_FOUND\n\n  const prerenderedRoutesByPathname = new Map<string, PrerenderedRoute>()\n\n  // Convert rootParamKeys to Set for O(1) lookup.\n  const rootParamSet = new Set(rootParamKeys)\n\n  if (hadAllParamsGenerated || isRoutePPREnabled) {\n    let paramsToProcess = routeParams\n\n    if (isRoutePPREnabled) {\n      // Discover all unique combinations of the routeParams so we can generate\n      // routes that won't throw on empty static shell for each of them if\n      // they're available.\n      paramsToProcess = generateAllParamCombinations(\n        childrenRouteParamSegments,\n        routeParams,\n        rootParamKeys\n      )\n\n      // The fallback route params for this route is a combination of the\n      // parallel route params and the non-parallel route params.\n      const fallbackRouteParams: readonly FallbackRouteParam[] = [\n        ...childrenRouteParamSegments.map(({ paramName, paramType: type }) =>\n          createFallbackRouteParam(paramName, type, false)\n        ),\n        ...parallelFallbackRouteParams,\n      ]\n\n      // Add the base route, this is the route with all the placeholders as it's\n      // derived from the `page` string.\n      prerenderedRoutesByPathname.set(page, {\n        params: {},\n        pathname: page,\n        encodedPathname: page,\n        fallbackRouteParams,\n        fallbackMode: calculateFallbackMode(\n          dynamicParams,\n          rootParamKeys,\n          fallbackMode\n        ),\n        fallbackRootParams: rootParamKeys,\n        throwOnEmptyStaticShell: true,\n      })\n    }\n\n    filterUniqueParams(\n      childrenRouteParamSegments,\n      validateParams(\n        page,\n        isRoutePPREnabled,\n        childrenRouteParamSegments,\n        rootParamKeys,\n        paramsToProcess\n      )\n    ).forEach((params) => {\n      let pathname = page\n      let encodedPathname = page\n\n      const fallbackRouteParams: FallbackRouteParam[] = []\n\n      for (const {\n        paramName: key,\n        paramType: type,\n      } of childrenRouteParamSegments) {\n        const paramValue = params[key]\n\n        if (!paramValue) {\n          if (isRoutePPREnabled) {\n            // Mark remaining params as fallback params.\n            fallbackRouteParams.push(createFallbackRouteParam(key, type, false))\n            for (\n              let i =\n                childrenRouteParamSegments.findIndex(\n                  (param) => param.paramName === key\n                ) + 1;\n              i < childrenRouteParamSegments.length;\n              i++\n            ) {\n              fallbackRouteParams.push(\n                createFallbackRouteParam(\n                  childrenRouteParamSegments[i].paramName,\n                  childrenRouteParamSegments[i].paramType,\n                  false\n                )\n              )\n            }\n            break\n          } else {\n            // This route is not complete, and we aren't performing a partial\n            // prerender, so we should return, skipping this route.\n            return\n          }\n        }\n\n        const segment = childrenRouteParamSegments.find(\n          ({ paramName }) => paramName === key\n        )\n        if (!segment) {\n          throw new InvariantError(\n            `Param ${key} not found in childrenRouteParamSegments ${childrenRouteParamSegments.map(({ paramName }) => paramName).join(', ')}`\n          )\n        }\n\n        pathname = pathname.replace(\n          segment.name,\n          encodeParam(paramValue, (value) => escapePathDelimiters(value, true))\n        )\n        encodedPathname = encodedPathname.replace(\n          segment.name,\n          encodeParam(paramValue, encodeURIComponent)\n        )\n      }\n\n      // Resolve parallel route params from the loader tree if this is from an\n      // app page.\n      if (\n        'loaderTree' in ComponentMod.routeModule.userland &&\n        Array.isArray(ComponentMod.routeModule.userland.loaderTree)\n      ) {\n        resolveParallelRouteParams(\n          ComponentMod.routeModule.userland.loaderTree,\n          params,\n          pathname,\n          fallbackRouteParams\n        )\n      }\n\n      const fallbackRootParams: string[] = []\n      for (const { paramName, isParallelRouteParam } of fallbackRouteParams) {\n        // Only add the param to the fallback root params if it's not a\n        // parallel route param. They won't contribute to the request pathname.\n        if (isParallelRouteParam) continue\n\n        // If the param is a root param then we can add it to the fallback\n        // root params.\n        if (rootParamSet.has(paramName)) {\n          fallbackRootParams.push(paramName)\n        }\n      }\n\n      pathname = normalizePathname(pathname)\n\n      prerenderedRoutesByPathname.set(pathname, {\n        params,\n        pathname,\n        encodedPathname: normalizePathname(encodedPathname),\n        fallbackRouteParams,\n        fallbackMode: calculateFallbackMode(\n          dynamicParams,\n          fallbackRootParams,\n          fallbackMode\n        ),\n        fallbackRootParams,\n        throwOnEmptyStaticShell: true,\n      })\n    })\n  }\n\n  const prerenderedRoutes =\n    prerenderedRoutesByPathname.size > 0 ||\n    lastDynamicSegmentHadGenerateStaticParams\n      ? [...prerenderedRoutesByPathname.values()]\n      : undefined\n\n  // Now we have to set the throwOnEmptyStaticShell for each of the routes.\n  if (prerenderedRoutes && cacheComponents) {\n    assignErrorIfEmpty(prerenderedRoutes, childrenRouteParamSegments)\n  }\n\n  return { fallbackMode, prerenderedRoutes }\n}\n"],"names":["assignErrorIfEmpty","buildAppStaticPaths","calculateFallbackMode","filterUniqueParams","generateAllParamCombinations","generateRouteStaticParams","resolveParallelRouteParams","childrenRouteParams","routeParams","unique","Map","params","key","paramName","paramKey","value","valuePart","Array","isArray","join","undefined","has","set","from","values","rootParamKeys","combinations","minIndexForCompleteRootParams","length","rootParamKey","index","findIndex","param","Math","max","i","combination","keyParts","hasAllRootParams","j","routeKey","hasOwnProperty","includes","push","currentKey","dynamicParams","fallbackRootParams","baseFallbackMode","FallbackMode","BLOCKING_STATIC_RENDER","NOT_FOUND","validateParams","page","isRoutePPREnabled","childrenRouteParamSegments","valid","some","Error","item","paramType","repeat","optional","getParamProperties","paramValue","prerenderedRoutes","root","children","routes","route","currentNode","valueKey","childNode","get","stack","node","pop","hasChildren","size","minFallbacks","Infinity","r","min","fallbackRouteParams","throwOnEmptyStaticShell","child","loaderTree","pathname","tree","depth","parallelKey","pathSegments","split","filter","Boolean","segment","parallelRoutes","parseLoaderTree","segmentParam","getSegmentParam","type","isParallelRouteParam","createFallbackRouteParam","remainingSegments","slice","hasUnknownParam","processedSegments","flatMap","pathSegment","s","InvariantError","nextDepth","isInterceptionRoute","INTERCEPTION_ROUTE_MARKERS","marker","startsWith","isRouteGroup","endsWith","Object","entries","segments","store","queue","segmentIndex","currentParams","current","shift","generateStaticParams","config","fetchCache","nextParams","parentParams","result","throwEmptyGenerateStaticParamsError","dir","distDir","cacheComponents","authInterrupts","isrFlushToDisk","cacheHandler","cacheLifeProfiles","requestHeaders","cacheHandlers","cacheMaxMemorySize","fetchCacheKeyPrefix","nextConfigOutput","ComponentMod","buildId","generate","patchFetch","incrementalCache","createIncrementalCache","flushToDisk","parallelFallbackRouteParams","nonParallelParamNames","Set","isParallelRouteSegment","add","name","afterRunner","AfterRunner","createWorkStore","renderOpts","supportsDynamicResponse","experimental","waitUntil","context","onClose","onAfterTaskError","onTaskError","previouslyRevalidatedTags","workAsyncStorage","run","executeAfter","lastDynamicSegmentHadGenerateStaticParams","isDynamicSegment","relative","filePath","path","hadAllParamsGenerated","every","supportsRoutePreGeneration","process","env","NODE_ENV","fallbackMode","PRERENDER","prerenderedRoutesByPathname","rootParamSet","paramsToProcess","map","encodedPathname","forEach","find","replace","encodeParam","escapePathDelimiters","encodeURIComponent","routeModule","userland","normalizePathname"],"mappings":"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","ignoreList":[0]}