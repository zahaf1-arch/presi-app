{"version":3,"sources":["../../../../src/server/app-render/app-render-render-utils.ts"],"sourcesContent":["import { InvariantError } from '../../shared/lib/invariant-error'\n\n/**\n * This is a utility function to make scheduling sequential tasks that run back to back easier.\n * We schedule on the same queue (setTimeout) at the same time to ensure no other events can sneak in between.\n */\nexport function scheduleInSequentialTasks<R>(\n  render: () => R | Promise<R>,\n  followup: () => void\n): Promise<R> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`scheduleInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      let pendingResult: R | Promise<R>\n      setTimeout(() => {\n        try {\n          pendingResult = render()\n        } catch (err) {\n          reject(err)\n        }\n      }, 0)\n      setTimeout(() => {\n        followup()\n        resolve(pendingResult)\n      }, 0)\n    })\n  }\n}\n\n/**\n * This is a utility function to make scheduling sequential tasks that run back to back easier.\n * We schedule on the same queue (setTimeout) at the same time to ensure no other events can sneak in between.\n * The function that runs in the second task gets access to the first tasks's result.\n */\nexport function pipelineInSequentialTasks<A, B, C>(\n  one: () => A,\n  two: (a: A) => B,\n  three: (b: B) => C | Promise<C>\n): Promise<C> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      '`pipelineInSequentialTasks` should not be called in edge runtime.'\n    )\n  } else {\n    return new Promise((resolve, reject) => {\n      let oneResult: A | undefined = undefined\n      setTimeout(() => {\n        try {\n          oneResult = one()\n        } catch (err) {\n          clearTimeout(twoId)\n          clearTimeout(threeId)\n          reject(err)\n        }\n      }, 0)\n\n      let twoResult: B | undefined = undefined\n      const twoId = setTimeout(() => {\n        // if `one` threw, then this timeout would've been cleared,\n        // so if we got here, we're guaranteed to have a value.\n        try {\n          twoResult = two(oneResult!)\n        } catch (err) {\n          clearTimeout(threeId)\n          reject(err)\n        }\n      }, 0)\n\n      const threeId = setTimeout(() => {\n        // if `two` threw, then this timeout would've been cleared,\n        // so if we got here, we're guaranteed to have a value.\n        try {\n          resolve(three(twoResult!))\n        } catch (err) {\n          reject(err)\n        }\n      }, 0)\n    })\n  }\n}\n"],"names":["InvariantError","scheduleInSequentialTasks","render","followup","process","env","NEXT_RUNTIME","Promise","resolve","reject","pendingResult","setTimeout","err","pipelineInSequentialTasks","one","two","three","oneResult","undefined","clearTimeout","twoId","threeId","twoResult"],"mappings":"AAAA,SAASA,cAAc,QAAQ,mCAAkC;AAEjE;;;CAGC,GACD,OAAO,SAASC,0BACdC,MAA4B,EAC5BC,QAAoB;IAEpB,IAAIC,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;QACvC,MAAM,qBAEL,CAFK,IAAIN,eACR,sEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;QACL,OAAO,IAAIO,QAAQ,CAACC,SAASC;YAC3B,IAAIC;YACJC,WAAW;gBACT,IAAI;oBACFD,gBAAgBR;gBAClB,EAAE,OAAOU,KAAK;oBACZH,OAAOG;gBACT;YACF,GAAG;YACHD,WAAW;gBACTR;gBACAK,QAAQE;YACV,GAAG;QACL;IACF;AACF;AAEA;;;;CAIC,GACD,OAAO,SAASG,0BACdC,GAAY,EACZC,GAAgB,EAChBC,KAA+B;IAE/B,IAAIZ,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;QACvC,MAAM,qBAEL,CAFK,IAAIN,eACR,sEADI,qBAAA;mBAAA;wBAAA;0BAAA;QAEN;IACF,OAAO;QACL,OAAO,IAAIO,QAAQ,CAACC,SAASC;YAC3B,IAAIQ,YAA2BC;YAC/BP,WAAW;gBACT,IAAI;oBACFM,YAAYH;gBACd,EAAE,OAAOF,KAAK;oBACZO,aAAaC;oBACbD,aAAaE;oBACbZ,OAAOG;gBACT;YACF,GAAG;YAEH,IAAIU,YAA2BJ;YAC/B,MAAME,QAAQT,WAAW;gBACvB,2DAA2D;gBAC3D,uDAAuD;gBACvD,IAAI;oBACFW,YAAYP,IAAIE;gBAClB,EAAE,OAAOL,KAAK;oBACZO,aAAaE;oBACbZ,OAAOG;gBACT;YACF,GAAG;YAEH,MAAMS,UAAUV,WAAW;gBACzB,2DAA2D;gBAC3D,uDAAuD;gBACvD,IAAI;oBACFH,QAAQQ,MAAMM;gBAChB,EAAE,OAAOV,KAAK;oBACZH,OAAOG;gBACT;YACF,GAAG;QACL;IACF;AACF","ignoreList":[0]}