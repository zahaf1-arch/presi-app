{"version":3,"sources":["../../../../../../src/client/components/router-reducer/reducers/navigate-reducer.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../shared/lib/app-router-types'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  Mutable,\n  NavigateAction,\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\n\nimport {\n  navigate as navigateUsingSegmentCache,\n  type NavigationResult,\n} from '../../segment-cache/navigation'\nimport { NavigationResultTag } from '../../segment-cache/types'\nimport { getStaleTimeMs } from '../../segment-cache/cache'\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nexport const DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nexport const STATIC_STALETIME_MS = getStaleTimeMs(\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME)\n)\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nexport function generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nfunction handleNavigationResult(\n  url: URL,\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  pendingPush: boolean,\n  result: NavigationResult\n): ReducerState {\n  switch (result.tag) {\n    case NavigationResultTag.MPA: {\n      // Perform an MPA navigation.\n      const newUrl = result.data\n      return handleExternalUrl(state, mutable, newUrl, pendingPush)\n    }\n    case NavigationResultTag.NoOp: {\n      // The server responded with no change to the current page. However, if\n      // the URL changed, we still need to update that.\n      const newCanonicalUrl = result.data.canonicalUrl\n      mutable.canonicalUrl = newCanonicalUrl\n\n      // Check if the only thing that changed was the hash fragment.\n      const oldUrl = new URL(state.canonicalUrl, url)\n      const onlyHashChange =\n        // We don't need to compare the origins, because client-driven\n        // navigations are always same-origin.\n        url.pathname === oldUrl.pathname &&\n        url.search === oldUrl.search &&\n        url.hash !== oldUrl.hash\n      if (onlyHashChange) {\n        // The only updated part of the URL is the hash.\n        mutable.onlyHashChange = true\n        mutable.shouldScroll = result.data.shouldScroll\n        mutable.hashFragment = url.hash\n        // Setting this to an empty array triggers a scroll for all new and\n        // updated segments. See `ScrollAndFocusHandler` for more details.\n        mutable.scrollableSegments = []\n      }\n\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Success: {\n      // Received a new result.\n      mutable.cache = result.data.cacheNode\n      mutable.patchedTree = result.data.flightRouterState\n      mutable.renderedSearch = result.data.renderedSearch\n      mutable.canonicalUrl = result.data.canonicalUrl\n      mutable.scrollableSegments = result.data.scrollableSegments\n      mutable.shouldScroll = result.data.shouldScroll\n      mutable.hashFragment = result.data.hash\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Async: {\n      return result.data.then(\n        (asyncResult) =>\n          handleNavigationResult(url, state, mutable, pendingPush, asyncResult),\n        // If the navigation failed, return the current state.\n        // TODO: This matches the current behavior but we need to do something\n        // better here if the network fails.\n        () => {\n          return state\n        }\n      )\n    }\n    default: {\n      result satisfies never\n      return state\n    }\n  }\n}\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll } = action\n  const mutable: Mutable = {}\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n\n  mutable.preserveCustomHistoryState = false\n  mutable.pendingPush = pendingPush\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return handleExternalUrl(state, mutable, href, pendingPush)\n  }\n\n  // Temporary glue code between the router reducer and the new navigation\n  // implementation. Eventually we'll rewrite the router reducer to a\n  // state machine.\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const result = navigateUsingSegmentCache(\n    url,\n    currentUrl,\n    state.cache,\n    state.tree,\n    state.nextUrl,\n    shouldScroll,\n    mutable\n  )\n  return handleNavigationResult(url, state, mutable, pendingPush, result)\n}\n"],"names":["createHrefFromUrl","handleMutable","navigate","navigateUsingSegmentCache","NavigationResultTag","getStaleTimeMs","DYNAMIC_STALETIME_MS","Number","process","env","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","STATIC_STALETIME_MS","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","handleExternalUrl","state","mutable","url","pendingPush","mpaNavigation","canonicalUrl","scrollableSegments","undefined","generateSegmentsFromPatch","flightRouterPatch","segments","segment","parallelRoutes","Object","keys","length","parallelRouteKey","parallelRoute","entries","childSegment","push","handleNavigationResult","result","tag","MPA","newUrl","data","NoOp","newCanonicalUrl","oldUrl","URL","onlyHashChange","pathname","search","hash","shouldScroll","hashFragment","Success","cache","cacheNode","patchedTree","flightRouterState","renderedSearch","Async","then","asyncResult","navigateReducer","action","isExternalUrl","navigateType","href","preserveCustomHistoryState","toString","document","getElementById","currentUrl","location","origin","tree","nextUrl"],"mappings":"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","ignoreList":[0]}